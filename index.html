<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fissure Runner</title>
  <style>
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      height: 100vh;
      margin: 0;
      background: #09090b;
      color: #e4e4e7;
      overflow: hidden; /* Prevent body scroll, let containers scroll */
      font-size: 13px;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: #3f3f46;
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #52525b;
    }

    .app-container {
      display: flex;
      height: 100%;
      width: 100%;
      overflow-x: auto;
      background: #09090b;
    }

    .layout-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem;
      overflow-y: auto;
      min-width: 320px;
      min-height: 0;
    }

    .layout-column.editing {
      border: 1px dashed #3f3f46;
      background: rgba(255, 255, 255, 0.02);
      min-height: 100px;
    }

    .draggable-panel {
      position: relative;
      transition: transform 0.2s, box-shadow 0.2s;
      overflow: hidden;
      flex-shrink: 0;
    }


    #wrapper {
      padding: 1.25rem;
      border-radius: 8px;
      background: #18181b;
      border: 1px solid #27272a;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      width: 100%;
      box-sizing: border-box;
    }

    .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #a1a1aa;
      margin-bottom: 0.25rem;
      font-weight: 600;
    }

    .value {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #fff;
    }

    .divider {
      height: 1px;
      background: #27272a;
      margin: 0.75rem 0;
    }

    .counter-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      color: #a1a1aa;
    }

    .mode-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .mode-btn {
      flex: 1;
      padding: 0.4rem 0;
      font-size: 0.8rem;
      border-radius: 6px;
      border: 1px solid #27272a;
      background: #27272a;
      color: #a1a1aa;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .mode-btn:hover {
      background: #3f3f46;
      color: #fff;
    }

    .mode-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }

    .buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    button {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.15s ease;
      flex: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    #nextBtn {
      background: #10b981;
      color: #000;
    }

    #nextBtn:hover { filter: brightness(1.1); transform: translateY(-1px); }

    #resetBtn {
      background: #3f3f46;
      color: #e4e4e7;
    }

    #resetBtn:hover { background: #52525b; transform: translateY(-1px); }

    #startBtn {
      background: #f59e0b;
      color: #000;
      flex: none;
      margin-left: 0;
    }

    #startBtn:hover { filter: brightness(1.1); }

    button:active {
      transform: translateY(1px);
    }

    /* Inputs */
    input[type="text"], input[type="number"] {
      background: #27272a;
      border: 1px solid #3f3f46;
      color: #e4e4e7;
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.85rem;
      outline: none;
      transition: border-color 0.2s;
      font-family: inherit;
    }
    input[type="text"]:focus, input[type="number"]:focus {
      border-color: #6366f1;
    }

    /* --- HOTKEY SETTINGS CSS (fixed) --- */

    .settings-card {
      background: #18181b;
      border: 1px solid #27272a;
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 1rem;
      height: 42px;
      cursor: pointer;
      user-select: none;
    }

    .settings-header .chevron {
      width: 16px;
      height: 16px;
      stroke: #a1a1aa;
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .settings-content {
      display: grid;
      grid-template-rows: 1fr;
      transition: grid-template-rows 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.3s;
      opacity: 1;
      overflow: hidden;
    }

    .settings-content.collapsed {
      grid-template-rows: 0fr;
      opacity: 0;
      visibility: hidden;
    }

    .settings-inner {
      padding: 0 1rem 1rem 1rem;
      overflow: hidden;
      min-height: 0;
    }

    .settings-card.collapsed .chevron {
      transform: rotate(-90deg);
    }

    #hotkeySettings, #autoScannerSettings, #osdSettings {
      box-shadow: none;
      border: none;
    }

    .settings-header h3 {
      margin: 0;
      font-size: 0.9rem;
      color: #e4e4e7;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      line-height: normal;
      padding-top: 1px;
    }
    
    .settings-card[data-setting-key="hotkeySettingsCollapsed"] .settings-header h3::before {
        content: '';
        display: block;
        width: 3px;
        height: 1em;
        background: #facc15;
        border-radius: 2px;
    }

    .hotkey-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      font-size: 0.9rem;
    }

    .hotkey-label {
      color: #a1a1aa;
    }

    .hotkey-value {
      font-weight: bold;
      color: #10b981;
      background: rgba(16, 185, 129, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .record-btn {
      width: 100%;
      background: #27272a;
      border: 1px solid #3f3f46;
      color: #e4e4e7;
    }

    .record-btn:hover {
      background: #3f3f46;
      border-color: #6366f1;
    }

    .record-status {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #a1a1aa;
      text-align: center;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .recording {
      opacity: 1 !important;
      color: #f87171 !important;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #3f3f46; /* Default/disabled color */
      transition: background-color 0.3s;
      flex-shrink: 0;
    }
    .status-dot.idle {
      background-color: #a1a1aa; /* Grey for enabled but not running */
    }
    .status-dot.active {
      background-color: #10b981; /* Green for active */
      animation: pulse 2s infinite;
    }
    .status-dot.paused {
      background-color: #f59e0b; /* Yellow/Orange for paused */
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
      70% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0); }
      100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
    }

    /* --- AUTO SCANNER CSS --- */
    .settings-card[data-setting-key="autoScannerSettingsCollapsed"] .settings-header h3::before {
        content: '';
        display: block;
        width: 3px;
        height: 1em;
        background: #6366f1;
        border-radius: 2px;
    }
    .scanner-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      font-size: 0.9rem;
      color: #a1a1aa;
    }
    #setScanAreaBtn {
      width: 100%;
      background: #27272a;
      border: 1px solid #3f3f46;
      color: #e4e4e7;
      margin-bottom: 0.5rem;
    }
    #setScanAreaBtn:hover { background: #3f3f46; border-color: #3b82f6; }
    #scanAreaDisplay {
      font-size: 0.75rem;
      color: #71717a;
      font-style: italic;
      text-align: center;
    }
    #scanPauseInput {
      width: 50px;
      background: #27272a; border: 1px solid #3f3f46; color: #e4e4e7; border-radius: 4px; padding: 2px 5px;
      text-align: center;
    }

    /* --- OSD SETTINGS CSS --- */
    .settings-card[data-setting-key="osdSettingsCollapsed"] .settings-header h3::before {
        content: '';
        display: block;
        width: 3px;
        height: 1em;
        background: #10b981;
        border-radius: 2px;
    }

    /* --- FISSURE SIDEBAR CSS --- */
    .fissure-panel-content {
      background: #121214;
      border: 1px solid #27272a;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      position: relative;
      height: 100%;
      min-height: 400px;
    }

    .fissure-header {
      padding: 1rem;
      background: #18181b;
      border-bottom: 1px solid #27272a;
      font-weight: 600;
      font-size: 0.9rem;
      color: #e4e4e7;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .refresh-btn {
      background: #27272a;
      border: 1px solid #3f3f46;
      color: #a1a1aa;
      padding: 0.25rem 0.5rem;
      font-size: 0.7rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .refresh-btn:hover { background: #3f3f46; color: #fff; }

    .fissure-list {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
      padding-bottom: 4rem;
    }

    .fissure-group {
      margin-bottom: 0.5rem;
    }

    .group-header {
      font-size: 0.7rem;
      font-weight: 700;
      color: #71717a;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.25rem;
      padding: 0.25rem 0.5rem;
      background: rgba(255,255,255,0.03);
      border-radius: 4px;
    }

    .reset-timers-container {
      display: flex;
      flex-direction: column;
      padding: 0.5rem 1rem;
      background: #18181b;
      border-bottom: 1px solid #27272a;
      gap: 4px;
    }
    .reset-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #a1a1aa;
      align-items: center;
    }
    .reset-tier { font-weight: 600; color: #e4e4e7; width: 60px; }
    .reset-val { display: flex; gap: 6px; }

    /* Filter Menu */
    .filter-menu {
      background: #18181b;
      border-bottom: 1px solid #27272a;
      padding: 1rem;
      display: none;
      flex-direction: column;
      gap: 1rem;
      max-height: 400px;
      overflow-y: auto;
    }
    .filter-menu.visible {
      display: flex;
    }
    .filter-section-title {
      font-size: 0.75rem;
      font-weight: 700;
      color: #71717a;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
      border-bottom: 1px solid #27272a;
      padding-bottom: 0.25rem;
    }
    .filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap: 0.5rem;
    }
    .filter-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #d4d4d8;
      cursor: pointer;
      user-select: none;
    }
    .filter-option input[type="checkbox"] {
      accent-color: #6366f1;
      cursor: pointer;
      margin: 0;
    }

    .fissure-item {
      background: #1e1e21;
      margin-bottom: 2px;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      border-left: 3px solid #555;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.1s;
    }
    .fissure-item:hover {
        background: #27272a;
    }

    .fissure-item.Lith { border-color: #a8a29e; }
    .fissure-item.Meso { border-color: #60a5fa; }
    .fissure-item.Neo { border-color: #f87171; }
    .fissure-item.Axi { border-color: #facc15; }
    .fissure-item.Requiem { border-color: #a78bfa; }
    .fissure-item.Omnia { border-color: #10b981; }

    .fissure-info {
      display: flex;
      flex-direction: column;
    }
    .fissure-main {
      font-size: 0.85rem;
      font-weight: 500;
      color: #f4f4f5;
      display: flex;
      align-items: center;
    }
    .sp-icon {
      width: 14px;
      height: 14px;
      margin-left: 6px;
      fill: #ef4444;
    }
    .fissure-sub {
      font-size: 0.7rem;
      color: #a1a1aa;
    }
    .fissure-timer {
      font-size: 0.75rem;
      color: #a1a1aa;
      text-align: right;
      min-width: 60px;
      font-variant-numeric: tabular-nums;
      background: rgba(0,0,0,0.2);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .settings-btn {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      top: auto;
      background: #18181b;
      border: 1px solid #27272a;
      color: #a1a1aa;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 50%;
      transition: background 0.2s, color 0.2s;
      z-index: 500;
      width: auto;
      flex: none;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .discord-col {
      width: 100%;
      height: 100%;
      background: #313338;
      border: 1px solid #27272a;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow: hidden;
    }
    .discord-header {
      padding: 0.75rem;
      background: #2b2d31;
      border-bottom: 1px solid #1e1f22;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #f2f3f5;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .settings-btn:hover {
      background: #27272a;
      color: #fff;
    }
    .settings-btn svg {
      width: 24px;
      height: 24px;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.2s;
      pointer-events: none;
    }
    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    .modal-content {
      background: #18181b;
      border: 1px solid #27272a;
      border-radius: 8px;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      transform: scale(0.95);
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .modal-overlay.visible .modal-content {
      transform: scale(1);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .modal-header h3 {
      margin: 0;
      color: #e4e4e7;
      font-size: 1.1rem;
    }
    .close-modal {
      background: transparent;
      border: none;
      color: #a1a1aa;
      cursor: pointer;
      padding: 0;
      width: auto;
      flex: none;
    }
    .close-modal:hover {
      color: #fff;
    }

    .hydration-popup {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: #10b981;
      color: #fff;
      padding: 0.8rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
      font-weight: 600;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease, transform 0.5s ease;
    }
    .hydration-popup.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  </style>
</head>

<body>
  <div class="app-container" id="layoutContainer">
    <!-- Column 2 -->
    <div id="col-2" class="layout-column">
      <div id="panel-runner" class="draggable-panel">
      <div id="wrapper">
        <div style="margin-bottom: 0.75rem;">
          <div class="label">Current Relic</div>
          <input type="text" id="relicName" placeholder="e.g., Axi A1" style="width: 100%; box-sizing: border-box;">
        </div>
        <div>
          <div class="label">Now running</div>
          <div id="now" class="value">‚Äî</div>
        </div>

        <div class="divider"></div>

        <div>
          <div class="label">Next / upcoming</div>
          <div id="next" class="value">Select mode & start relic</div>
        </div>

        <div class="divider"></div>

        <div class="counter-row">
          <span>Total cycles:</span>
          <div>
            <span id="cycleState" style="font-size: 0.8rem; font-weight: 600; margin-right: 8px;"></span>
            <span id="counter">0</span>
          </div>
        </div>

        <div class="mode-row">
          <button class="mode-btn rotation-btn active" data-mode="4b4">4b4</button>
          <button class="mode-btn rotation-btn" data-mode="2b2">2b2</button>
          <button class="mode-btn rotation-btn" data-mode="1b1">1b1</button>
          <button id="cascadeBtn" class="mode-btn">Cascade</button>
        </div>

        <!-- 1b1 Settings -->
        <div id="settings1b1" style="display: none; margin-bottom: 0.75rem;">
            <div class="label">1b1 Running Position</div>
            <div class="mode-row">
                <button class="mode-btn pos-btn active" data-pos="1">1st</button>
                <button class="mode-btn pos-btn" data-pos="2">2nd</button>
                <button class="mode-btn pos-btn" data-pos="3">3rd</button>
                <button class="mode-btn pos-btn" data-pos="4">4th</button>
            </div>
        </div>

        <div class="buttons">
          <button id="startBtn">Start: Running</button>
          <button id="nextBtn">Next</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>
      </div>

      <div id="panel-hotkey" class="draggable-panel">
      <div class="settings-card" data-setting-key="hotkeySettingsCollapsed" style="width: 100%;">
        <div class="settings-header">
          <h3>Hotkey Settings</h3>
          <svg class="chevron" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
        </div>
        <div id="hotkeySettings" class="settings-content">
          <div class="settings-inner">
            <div class="hotkey-row">
              <span class="hotkey-label">Current Hotkey:</span>
              <span id="currentHotkey" class="hotkey-value"></span>
            </div>
            <div class="hotkey-row">
              <label for="hotkeyEnabledToggle" style="cursor: pointer; color: #a1a1aa;">Enable Hotkey</label>
              <input type="checkbox" id="hotkeyEnabledToggle" style="cursor: pointer;" />
            </div>
            <button id="recordHotkeyBtn" class="record-btn">Record New Hotkey</button>
            <div id="recordStatus" class="record-status">Press any key‚Ä¶</div>
          </div>
        </div>
      </div>
      </div>

      <div id="panel-scanner" class="draggable-panel">
      <div class="settings-card" data-setting-key="autoScannerSettingsCollapsed" style="width: 100%;">
        <div class="settings-header">
          <h3>Auto-Scanner</h3>
          <svg class="chevron" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
        </div>
        <div id="autoScannerSettings" class="settings-content">
          <div class="settings-inner">
            <div class="scanner-row">
              <label for="autoScanToggle" style="cursor: pointer; display: flex; align-items: center; gap: 8px;">
                <span id="scannerStatusDot" class="status-dot"></span>
                Enable Auto-Scanner
                <span id="scannerCountdown" style="font-size: 0.8rem; color: #f59e0b; font-weight: 600;"></span>
              </label>
              <input type="checkbox" id="autoScanToggle" style="cursor: pointer;" />
            </div>
            <div class="scanner-row">
              <label for="scanPauseInput">Pause (seconds)</label>
              <input type="number" id="scanPauseInput" min="5" value="30" />
            </div>
            <div class="scanner-row">
              <label for="scanIntervalNormalInput">Normal Interval (s)</label>
              <input type="number" id="scanIntervalNormalInput" min="1" value="10" style="width: 50px; background: #27272a; border: 1px solid #3f3f46; color: #e4e4e7; border-radius: 4px; padding: 2px 5px; text-align: center;" />
            </div>
            <div class="scanner-row">
              <label for="scanIntervalCascadeInput">Cascade Interval (s)</label>
              <input type="number" id="scanIntervalCascadeInput" min="1" value="5" style="width: 50px; background: #27272a; border: 1px solid #3f3f46; color: #e4e4e7; border-radius: 4px; padding: 2px 5px; text-align: center;" />
            </div>
            <button id="setScanAreaBtn">Set Normal Scan Area</button>
            <button id="setVoidCascadeAreaBtn" class="record-btn" style="margin-top: 0.5rem;">Set Void Cascade Area</button>
            <div id="scanAreaDisplay">No area set.</div>
            <div class="scanner-row" style="margin-top: 0.5rem;">
              <label for="showScannerPreviewToggle" style="cursor: pointer;">Show Scanner Preview Button</label>
              <input type="checkbox" id="showScannerPreviewToggle" style="cursor: pointer;" />
            </div>
            <button id="testScannerBtn" class="record-btn" style="margin-top: 0.5rem; border-color: #eab308; color: #eab308;">Test Scanner (Preview)</button>
            <div id="scannerPreview" style="margin-top: 0.5rem; display: none; flex-direction: column; gap: 0.5rem;">
              <div style="font-size: 0.8rem; color: #a1a1aa;">Raw Text:</div>
              <div id="scannerRawText" style="font-family: monospace; background: #000; padding: 0.5rem; border-radius: 4px; color: #fff; font-size: 0.8rem; word-break: break-all;"></div>
              <div style="font-size: 0.8rem; color: #a1a1aa; margin-top: 0.25rem;">Processed Text:</div>
              <div id="scannerProcessedText" style="font-family: monospace; background: #000; padding: 0.5rem; border-radius: 4px; color: #eab308; font-size: 0.8rem; word-break: break-all;"></div>
              <div id="scannerMatchStatus" style="font-size: 0.8rem; color: #a1a1aa; margin-top: 0.25rem; font-weight: bold; text-align: center;"></div>
              <img id="scannerSnapshot" style="width: 100%; border: 1px solid #3f3f46; border-radius: 4px;" />
            </div>
          </div>
        </div>
      </div>
      </div>

      <div id="panel-osd" class="draggable-panel">
      <div class="settings-card" data-setting-key="osdSettingsCollapsed" style="width: 100%;">
        <div class="settings-header">
          <h3>On-Screen Display</h3>
          <svg class="chevron" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
        </div>
        <div id="osdSettings" class="settings-content">
          <div class="settings-inner">
            <div class="scanner-row" style="margin-bottom:0.75rem;">
              <label for="osdToggle" style="cursor: pointer; font-weight:600; color:#e4e4e7;">Enable OSD</label>
              <input type="checkbox" id="osdToggle" style="cursor: pointer;" />
            </div>
            <div class="scanner-row" style="margin-top: 0.5rem;">
              <label for="osdOpacity">Background Opacity</label>
              <input type="range" id="osdOpacity" min="0.2" max="1" step="0.1" style="width: 100px; accent-color: #6366f1;">
            </div>
            <div class="scanner-row">
              <label for="osdScale">Size</label>
              <input type="range" id="osdScale" min="0.5" max="2.0" step="0.1" style="width: 100px; accent-color: #6366f1;">
            </div>
            <div class="scanner-row" style="margin-top: 0.5rem;">
              <label for="osdLockToggle" style="cursor: pointer;">Lock Position (Click-through)</label>
              <input type="checkbox" id="osdLockToggle" style="cursor: pointer;" />
            </div>
            <div class="scanner-row" style="margin-top: 0.5rem;">
              <label for="hideOSDWhenEmptyToggle" style="cursor: pointer;">Hide when "Now Running" is empty</label>
              <input type="checkbox" id="hideOSDWhenEmptyToggle" style="cursor: pointer;" />
            </div>
          </div>
        </div>
      </div>
      </div>
    </div>

    <!-- Column 3 -->
    <div id="col-3" class="layout-column">
    <div id="panel-fissures" class="draggable-panel" style="height: 100%;">
    <div class="fissure-panel-content">
      <div class="fissure-header">
        <span>Active Fissures</span>
        <div style="display: flex; align-items: center; gap: 10px;">
          <button id="toggleFilters" class="refresh-btn">Filters</button>
          <span id="clock" style="font-size: 0.8rem; color: #9ca3af; font-variant-numeric: tabular-nums;"></span>
          <button id="refreshFissures" class="refresh-btn">Refresh</button>
        </div>
      </div>
      <div id="filterMenu" class="filter-menu">
        <!-- Filters injected here -->
      </div>
      <div id="resetTimers" class="reset-timers-container" style="display:none;"></div>
      <div id="fissureList" class="fissure-list">
        <div style="text-align:center; color:#666; margin-top:2rem;">Loading...</div>
      </div>
    </div>
    </div>
    </div>

    <div id="hydrationPopup" class="hydration-popup">üíß Time to drink some water!</div>
    
    <button id="settingsBtn" class="settings-btn" title="General Settings">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
    </button>

    <!-- General Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h3>General Settings</h3>
          <button id="closeSettingsBtn" class="close-modal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width:20px;height:20px;"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></button>
        </div>
        <div class="scanner-row">
          <label for="hydrationToggle" style="cursor: pointer;">Hydration Reminder</label>
          <input type="checkbox" id="hydrationToggle" style="cursor: pointer;" />
        </div>
        <div class="scanner-row" style="margin-top: 0.5rem;">
          <label for="hydrationIntervalInput">Interval (minutes)</label>
          <input type="number" id="hydrationIntervalInput" min="1" value="60" style="width: 60px; text-align: center; background: #27272a; border: 1px solid #3f3f46; color: #e4e4e7; border-radius: 4px; padding: 2px 5px;">
        </div>
        <div class="scanner-row" style="margin-top: 1rem; flex-direction: column; align-items: flex-start; gap: 0.5rem;">
          <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
            <span style="color:#a1a1aa; font-size:0.9rem;">Sound:</span>
            <span id="soundName" style="color:#fff; font-size:0.8rem; max-width:180px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">Default (QuackReverb)</span>
          </div>
          <div style="display:flex; gap:0.5rem; width:100%;">
            <button id="selectSoundBtn" class="refresh-btn" style="flex:1; padding:0.5rem;">Select File</button>
            <button id="resetSoundBtn" class="refresh-btn" style="flex:0 0 auto; background:#ef4444; color:white; display:none; padding:0.5rem 0.8rem;">X</button>
          </div>
        </div>
        <div class="scanner-row" style="margin-top: 0.5rem;">
          <label for="hydrationVolume">Volume</label>
          <input type="range" id="hydrationVolume" min="0" max="1" step="0.01" style="width: 100px; accent-color: #6366f1;">
        </div>
        <button id="testPopupBtn" class="record-btn" style="margin-top: 0.5rem;">Test Popup Now</button>
        
        <div class="divider"></div>
        <div class="label" style="margin-top: 1rem;">Layout Options</div>
        <div class="scanner-row">
          <label for="editLayoutToggle" style="cursor: pointer;">Edit Layout (Drag & Drop)</label>
          <input type="checkbox" id="editLayoutToggle" style="cursor: pointer;" />
        </div>
        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
          <button id="presetDefaultBtn" class="refresh-btn" style="flex:1;">Default</button>
          <button id="presetCompactBtn" class="refresh-btn" style="flex:1;">Compact</button>
        </div>
        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
          <button id="saveCustomLayoutBtn" class="refresh-btn" style="flex:1; border-color: #10b981; color: #10b981;">Save Custom</button>
          <button id="loadCustomLayoutBtn" class="refresh-btn" style="flex:1;">Load Custom</button>
        </div>
        
        <div class="divider"></div>
        <div class="label" style="margin-top: 1rem;">Updates</div>
        <button id="checkForUpdateBtn" class="record-btn">Check for Updates</button>
        <div id="updateStatus" style="font-size: 0.8rem; color: #a1a1aa; margin-top: 0.5rem; text-align: center;"></div>

        <div class="divider"></div>
        <div class="label" style="margin-top: 1rem;">Support</div>
        <button id="kofiBtn" class="record-btn" style="background-color: #FF5E5B; border-color: #FF5E5B; color: white;">Support me on Ko-fi ‚ù§Ô∏è</button>
      </div>
    </div>
  </div>

  <!-- Update Prompt Modal -->
  <div id="updateModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Update Available</h3>
        <button id="closeUpdateModalBtn" class="close-modal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width:20px;height:20px;"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></button>
      </div>
      <div id="updateModalContent">
        <p id="updateMessage" style="color: #e4e4e7; margin-bottom: 1.5rem;">A new version is available. Would you like to download it now?</p>
        <div class="buttons">
          <button id="downloadUpdateBtn" style="background: #10b981; color: #000;">Download Now</button>
          <button id="laterUpdateBtn" class="refresh-btn">Later</button>
          <button id="restartUpdateBtn" style="background: #10b981; color: #000; display: none;">Restart & Install</button>
        </div>
      </div>
    </div>
  </div>

  <style>
  </style>

  <script>
    /* --- your relic picker logic stays unchanged --- */

    const RUNNING = "Running relic";
    const TRASH = "Trash relic";

    const nowEl = document.getElementById("now");
    const nextEl = document.getElementById("next");
    const counterEl = document.getElementById("counter");
    const cycleStateEl = document.getElementById("cycleState");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const startBtn = document.getElementById("startBtn");
    const rotationBtns = document.querySelectorAll(".rotation-btn");
    const cascadeBtn = document.getElementById("cascadeBtn");
    const settings1b1 = document.getElementById("settings1b1");
    const posBtns = document.querySelectorAll(".pos-btn");
    const relicNameInput = document.getElementById("relicName");

    let currentMode = "4b4";
    let upcoming = null;
    let counter = 0;
    let startRelic = RUNNING;
    let trashCount = 0;
    let pressCount = 0;
    let isCascadeMode = false;
    let cycleStep = 0;
    let runningPosition = 1;

    rotationBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        rotationBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentMode = btn.dataset.mode;
        if (window.electronAPI && window.electronAPI.setRotationMode) {
          window.electronAPI.setRotationMode(currentMode);
          cycleStep = 0; // Reset step on mode change
          updateStartRelicFor1b1();
        }
        update1b1Visibility();
      });
    });

    posBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        posBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        runningPosition = parseInt(btn.dataset.pos);
        if (window.electronAPI && window.electronAPI.set1b1Position) {
          window.electronAPI.set1b1Position(runningPosition);
        }
        updateStartRelicFor1b1();
      });
    });

    function update1b1Visibility() {
      settings1b1.style.display = currentMode === "1b1" ? "block" : "none";
    }

    function updateStartRelicFor1b1() {
      if (currentMode === '1b1' && cycleStep === 0) {
        // If we are at the start of a cycle, set the start relic based on position
        startRelic = (runningPosition === 1) ? RUNNING : TRASH;
        startBtn.textContent = `Start: ${startRelic}`;
        if (upcoming !== null) {
           // If user hasn't started yet but upcoming is set (e.g. reset), update it
           // Note: usually upcoming is null until start is clicked, but this keeps UI consistent
        }
      }
    }

    cascadeBtn.addEventListener("click", () => {
      isCascadeMode = !isCascadeMode;
      cascadeBtn.classList.toggle("active", isCascadeMode);
      if (window.electronAPI && window.electronAPI.setVoidCascadeMode) {
        window.electronAPI.setVoidCascadeMode(isCascadeMode);
      }
    });

    let relicDebounceTimer;
    relicNameInput.addEventListener("input", () => {
      clearTimeout(relicDebounceTimer);
      relicDebounceTimer = setTimeout(() => {
        if (window.electronAPI && window.electronAPI.setRelicName) {
          window.electronAPI.setRelicName(relicNameInput.value);
        }
        broadcastOSD();
      }, 300);
    });

    startBtn.addEventListener("click", () => {
      startRelic = startRelic === RUNNING ? TRASH : RUNNING;
      startBtn.textContent = `Start: ${startRelic}`;
      if (upcoming !== null) {
        upcoming = startRelic;
        nextEl.textContent = upcoming;
      }
      broadcastOSD(); // Uses current cycleStateEl text
    });

    nextBtn.addEventListener("click", () => {
      if (upcoming === null) {
        upcoming = startRelic;
        nextEl.textContent = upcoming;
        broadcastOSD();
        return;
      }

      nowEl.textContent = upcoming;
      pressCount++;

      // Cycle Step Logic
      cycleStep++;
      if (currentMode === "2b2" && cycleStep > 2) cycleStep = 1;
      if (currentMode === "1b1" && cycleStep > 4) cycleStep = 1;
      if (currentMode === "4b4") cycleStep = 1;

      // Counter Logic
      if (currentMode === "4b4") counter += 1;
      else if (currentMode === "2b2") counter += 0.5;
      else if (currentMode === "1b1") counter += 0.25;

      counterEl.textContent = counter;

      // Determine Cycle State
      let cycleState = "";
      if (currentMode !== "4b4") {
        cycleState = (cycleStep === 1) ? "New Cycle" : "Mid Cycle";
      }

      cycleStateEl.textContent = cycleState;
      if (cycleState === "New Cycle") {
        cycleStateEl.style.color = '#10b981';
      } else {
        cycleStateEl.style.color = '#a1a1aa';
      }

      if (currentMode === "4b4") {
        upcoming = RUNNING;
      } else if (currentMode === "2b2") {
        upcoming = (upcoming === RUNNING) ? TRASH : RUNNING;
      } else if (currentMode === "1b1") {
        // Calculate next step (1-4)
        let nextStep = cycleStep + 1;
        if (nextStep > 4) nextStep = 1;
        
        if (nextStep === runningPosition) {
          upcoming = RUNNING;
        } else {
          upcoming = TRASH;
        }
      }

      nextEl.textContent = upcoming;
      broadcastOSD(); // cycleStateEl is already updated above
    });

    resetBtn.addEventListener("click", () => {
      counter = 0;
      pressCount = 0;
      trashCount = 0;
      upcoming = null;
      cycleStateEl.textContent = "";
      cycleStep = 0;
      nowEl.textContent = "‚Äî";
      nextEl.textContent = "Select mode & start relic";
      counterEl.textContent = counter;
      broadcastOSD();
      updateStartRelicFor1b1();
    });

    /* --- HOTKEY UI LOGIC --- */

    const recordBtn = document.getElementById("recordHotkeyBtn");
    const recordStatus = document.getElementById("recordStatus");
    const currentHotkeyEl = document.getElementById("currentHotkey");
    const hotkeyEnabledToggle = document.getElementById("hotkeyEnabledToggle");

    let recording = false;

    hotkeyEnabledToggle.addEventListener("change", () => {
      if (window.electronAPI && window.electronAPI.setHotkeyEnabled) {
        window.electronAPI.setHotkeyEnabled(hotkeyEnabledToggle.checked);
      }
    });

    recordBtn.addEventListener("click", () => {
      recording = true;
      recordStatus.classList.add("recording");
      recordStatus.textContent = "Listening‚Ä¶ press any key";
    });

    document.addEventListener("keydown", (e) => {
      if (!recording) return;

      e.preventDefault();

      // Ignore presses of only modifier keys
      if (['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
        return;
      }

      let newHotkey = e.key;

      // Map Arrow keys
      if (newHotkey === "ArrowUp") newHotkey = "Up";
      if (newHotkey === "ArrowDown") newHotkey = "Down";
      if (newHotkey === "ArrowLeft") newHotkey = "Left";
      if (newHotkey === "ArrowRight") newHotkey = "Right";

      // Fix Space key
      if (newHotkey === " ") newHotkey = "Space";

      // Only uppercase single characters, leave special keys (PageDown, F1, etc.) alone
      if (newHotkey.length === 1) {
        newHotkey = newHotkey.toUpperCase();
      }

      // Fix tilde/backtick
      if (newHotkey === "~") newHotkey = "Shift+`";
      if (newHotkey === "`") newHotkey = "`";


      currentHotkeyEl.textContent = newHotkey;
      recordStatus.textContent = "Saved!";
      recordStatus.classList.remove("recording");

      if (window.electronAPI) {
        window.electronAPI.setHotkey(newHotkey);
      }

      recording = false;
    });

    if (window.electronAPI) {
      window.electronAPI.onHotkeyNext(() => {
        nextBtn.click();
      });
    }
    if (window.electronAPI) {
  window.electronAPI.onLoadHotkey((event, savedHotkey) => {
    currentHotkeyEl.textContent = savedHotkey;
  });
}


    /* --- AUTO SCANNER LOGIC --- */
    const autoScanToggle = document.getElementById('autoScanToggle');
    const setScanAreaBtn = document.getElementById('setScanAreaBtn');
    const scannerStatusDot = document.getElementById('scannerStatusDot');
    const setVoidCascadeAreaBtn = document.getElementById('setVoidCascadeAreaBtn');
    const scanAreaDisplay = document.getElementById('scanAreaDisplay');
    const scanPauseInput = document.getElementById('scanPauseInput');
    const scanIntervalNormalInput = document.getElementById('scanIntervalNormalInput');
    const scanIntervalCascadeInput = document.getElementById('scanIntervalCascadeInput');
    const testScannerBtn = document.getElementById('testScannerBtn');
    const scannerPreview = document.getElementById('scannerPreview');
    const scannerRawText = document.getElementById('scannerRawText');
    const scannerProcessedText = document.getElementById('scannerProcessedText');
    const scannerMatchStatus = document.getElementById('scannerMatchStatus');    const scannerSnapshot = document.getElementById('scannerSnapshot');

    testScannerBtn.addEventListener('click', async () => {
      if (window.electronAPI && window.electronAPI.testScanner) {
        testScannerBtn.textContent = "Scanning...";
        testScannerBtn.disabled = true;
        scannerPreview.style.display = 'flex';
        scannerRawText.textContent = '...';
        scannerProcessedText.textContent = '...';
        scannerMatchStatus.textContent = '';
        scannerSnapshot.src = "";
        try {
          const result = await window.electronAPI.testScanner();
          if (result.error) {
            scannerRawText.textContent = "Error: " + result.error;
            scannerProcessedText.textContent = "N/A";            scannerSnapshot.src = "";
          } else {
            scannerRawText.textContent = result.rawText || "[No text detected]";
            scannerProcessedText.textContent = result.processedText || "[N/A]";
            if (result.match) {
              scannerMatchStatus.textContent = `‚úÖ Match Found (Mode: ${result.mode})`;
              scannerMatchStatus.style.color = '#10b981';
            } else {
              scannerMatchStatus.textContent = `‚ùå No Match Found (Mode: ${result.mode})`;
              scannerMatchStatus.style.color = '#f87171';
            }            scannerSnapshot.src = result.image;
          }
        } catch (e) {
          scannerRawText.textContent = "Error: " + e;
        } finally {
          testScannerBtn.textContent = "Test Scanner (Preview)";
          testScannerBtn.disabled = false;
        }
      }
    });

    function updateScanAreaDisplay(areas) {
      // Handle both old format (single area) and new format (object with keys)
      let normal = areas;
      let vc = null;
      
      if (areas && (areas.normal || areas.voidCascade)) {
        normal = areas.normal;
        vc = areas.voidCascade;
      }

      let text = '';
      if (normal && normal.width > 0) {
        text += `Normal: ${normal.width}x${normal.height} at (${normal.x}, ${normal.y})`;
      } else {
        text += 'Normal: Not set';
      }
      
      text += ' | ';
      
      if (vc && vc.width > 0) {
        text += `VC: ${vc.width}x${vc.height} at (${vc.x}, ${vc.y})`;
      } else {
        text += 'VC: Not set';
      }
      
      scanAreaDisplay.textContent = text;
    }

    setScanAreaBtn.addEventListener('click', () => {
      window.electronAPI.openScannerWindow('normal');
    });

    setVoidCascadeAreaBtn.addEventListener('click', () => {
      window.electronAPI.openScannerWindow('voidCascade');
    });

    autoScanToggle.addEventListener('change', () => {
      window.electronAPI.toggleAutoScan(autoScanToggle.checked);
      broadcastOSD();
    });

    scanPauseInput.addEventListener('change', () => {
      const val = parseInt(scanPauseInput.value);
      if (val > 0 && window.electronAPI) window.electronAPI.setAutoScanPause(val);
    });

    scanIntervalNormalInput.addEventListener('change', () => {
      const val = parseInt(scanIntervalNormalInput.value);
      if (val > 0 && window.electronAPI) window.electronAPI.setScanInterval('normal', val);
    });

    scanIntervalCascadeInput.addEventListener('change', () => {
      const val = parseInt(scanIntervalCascadeInput.value);
      if (val > 0 && window.electronAPI) window.electronAPI.setScanInterval('cascade', val);
    });

    window.electronAPI.onScanAreaUpdated((event, areas) => {
      updateScanAreaDisplay(areas);
    });

    let countdownInterval;
    window.electronAPI.onMissionCompleteDetected((event, duration) => {
      nextBtn.click();
      
      // Start Countdown UI
      const countdownEl = document.getElementById('scannerCountdown');
      let timeLeft = duration || 30;
      
      if (countdownInterval) clearInterval(countdownInterval);
      countdownEl.textContent = `(Resuming in ${timeLeft}s)`;
      
      countdownInterval = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          clearInterval(countdownInterval);
          countdownEl.textContent = "";
        } else {
          countdownEl.textContent = `(Resuming in ${timeLeft}s)`;
        }
      }, 1000);
    });

    if (window.electronAPI) {
      window.electronAPI.onResyncScannerState(() => {
        broadcastOSD();
      });
    }

    if (window.electronAPI) {
      window.electronAPI.onScannerStatusUpdate((event, status) => {
        scannerStatusDot.className = 'status-dot'; // Reset classes
        if (status) {
          scannerStatusDot.classList.add(status); // Add new status class (e.g., 'active')
        }
      });
    }

    /* --- OSD LOGIC --- */
    const osdToggle = document.getElementById('osdToggle');
    const osdOpacityInput = document.getElementById('osdOpacity');
    const osdScaleInput = document.getElementById('osdScale');
    const osdLockToggle = document.getElementById('osdLockToggle');
    const hideOSDWhenEmptyToggle = document.getElementById('hideOSDWhenEmptyToggle');
    
    osdToggle.addEventListener('change', () => {
      if (window.electronAPI) window.electronAPI.setOSDEnabled(osdToggle.checked);
    });

    // relicNameInput listener moved to debounce logic above

    function broadcastOSD() {
      if (window.electronAPI) window.electronAPI.updateOSD({ 
        now: nowEl.textContent, 
        next: nextEl.textContent, 
        relic: relicNameInput.value,
        cycleCount: counter,
        cycleState: cycleStateEl.textContent
      });
    }

    osdOpacityInput.addEventListener('input', () => {
      if (window.electronAPI) window.electronAPI.setOSDOpacity(parseFloat(osdOpacityInput.value));
    });

    osdScaleInput.addEventListener('input', () => {
      if (window.electronAPI) window.electronAPI.setOSDScale(parseFloat(osdScaleInput.value));
    });

    osdLockToggle.addEventListener('change', () => {
      if (window.electronAPI) window.electronAPI.setOSDLocked(osdLockToggle.checked);
    });

    hideOSDWhenEmptyToggle.addEventListener('change', () => {
      if (window.electronAPI) {
        window.electronAPI.setUISettings({ hideOSDWhenEmpty: hideOSDWhenEmptyToggle.checked });
        broadcastOSD();
      }
    });

    /* --- COLLAPSIBLE SETTINGS LOGIC --- */
    const settingsCards = document.querySelectorAll('.settings-card');
    let uiSettings = {};

    settingsCards.forEach(card => {
      const header = card.querySelector('.settings-header');
      const content = card.querySelector('.settings-content');
      const key = card.dataset.settingKey;

      // Initialize order for all panels to ensure consistent layout
      const initialDraggablePanel = card.closest('.draggable-panel');
      if (initialDraggablePanel) {
        initialDraggablePanel.style.order = 0;
      }

      header.addEventListener('click', () => {
        const isCollapsed = card.classList.toggle('collapsed');
        content.classList.toggle('collapsed');

        const draggablePanel = card.closest('.draggable-panel');
        if (draggablePanel) {
          if (isCollapsed) {
            draggablePanel.style.order = 1; // Move to bottom of flex group
          } else {
            draggablePanel.style.order = 0; // Return to normal order
          }

          if (isCollapsed) {
            // If resizing set a fixed height, save it and switch to auto so it shrinks
            if (draggablePanel.style.height && draggablePanel.style.height !== 'auto') {
              draggablePanel.dataset.savedHeight = draggablePanel.style.height;
            }
            draggablePanel.style.height = 'auto';
          } else {
            // Restore saved height if available
            if (draggablePanel.dataset.savedHeight) {
              draggablePanel.style.height = draggablePanel.dataset.savedHeight;
              delete draggablePanel.dataset.savedHeight;
            } else {
              draggablePanel.style.height = 'auto';
            }
          }
        }
        
        if (window.electronAPI) {
          uiSettings[key] = isCollapsed;
          window.electronAPI.setUISettings({ [key]: isCollapsed });
        }
      });
    });

    function applyUISettings(loadedUISettings) {
      settingsCards.forEach(card => {
        const key = card.dataset.settingKey;
        if (loadedUISettings[key]) {
          card.classList.add('collapsed');
          card.querySelector('.settings-content').classList.add('collapsed');
          const draggablePanel = card.closest('.draggable-panel');
          if (draggablePanel) {
            // Move panel to the bottom if it's loaded in a collapsed state
            draggablePanel.style.order = 1;
          }
        }
      });
    }

    /* --- GENERAL SETTINGS MODAL LOGIC --- */
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');

    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('visible');
    });

    closeSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.remove('visible');
    });

    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) settingsModal.classList.remove('visible');
    });

    /* --- HYDRATION REMINDER LOGIC --- */
    const hydrationToggle = document.getElementById('hydrationToggle');
    let hydrationInterval = null;
    let customAudio = null;

    hydrationToggle.addEventListener('change', () => {
      if (window.electronAPI) {
        window.electronAPI.setHydrationReminderEnabled(hydrationToggle.checked);
      }
      manageHydrationTimer();
    });

    const selectSoundBtn = document.getElementById('selectSoundBtn');
    const resetSoundBtn = document.getElementById('resetSoundBtn');
    const soundNameEl = document.getElementById('soundName');
    const hydrationVolumeInput = document.getElementById('hydrationVolume');
    const hydrationIntervalInput = document.getElementById('hydrationIntervalInput');

    selectSoundBtn.addEventListener('click', async () => {
      if (window.electronAPI) {
        const path = await window.electronAPI.selectHydrationSound();
        if (path) {
          window.electronAPI.setHydrationSound(path);
          updateSoundUI(path);
          loadCustomSoundData();
        }
      }
    });

    resetSoundBtn.addEventListener('click', () => {
      if (window.electronAPI) {
        window.electronAPI.setHydrationSound(null);
        updateSoundUI(null);
        loadCustomSoundData();
      }
    });

    function updateSoundUI(path) {
      if (path) {
        const fileName = path.split(/[\\/]/).pop();
        soundNameEl.textContent = fileName;
        resetSoundBtn.style.display = 'inline-block';
        selectSoundBtn.textContent = "Change File";
      } else {
        soundNameEl.textContent = "Default (QuackReverb)";
        resetSoundBtn.style.display = 'none';
        selectSoundBtn.textContent = "Select File";
      }
    }

    hydrationVolumeInput.addEventListener('input', () => {
      const vol = parseFloat(hydrationVolumeInput.value);
      if (customAudio) customAudio.volume = vol;
      if (window.electronAPI) window.electronAPI.setHydrationSoundVolume(vol);
    });

    hydrationIntervalInput.addEventListener('change', () => {
      const minutes = parseInt(hydrationIntervalInput.value);
      if (minutes > 0 && window.electronAPI) {
        window.electronAPI.setHydrationInterval(minutes);
      }
      manageHydrationTimer(); // Restart timer with new interval
    });

    async function loadCustomSoundData() {
      if (!window.electronAPI) return;
      const result = await window.electronAPI.readHydrationSound();
      if (result) {
        customAudio = new Audio(`data:${result.mime};base64,${result.data}`);
        const vol = parseFloat(hydrationVolumeInput.value);
        customAudio.volume = isNaN(vol) ? 0.5 : vol;
      } else {
        customAudio = null;
      }
    }

    const testPopupBtn = document.getElementById('testPopupBtn');
    testPopupBtn.addEventListener('click', () => {
      showHydrationReminder(true); // Force show for test
    });

    function manageHydrationTimer() {
      if (hydrationInterval) clearInterval(hydrationInterval);
      if (hydrationToggle.checked) {
        const intervalMinutes = parseInt(hydrationIntervalInput.value) || 60;
        const intervalMs = intervalMinutes * 60 * 1000;
        if (intervalMs > 0) hydrationInterval = setInterval(() => showHydrationReminder(false), intervalMs);
      }
    }

    function showHydrationReminder(isTest = false) {
      // Only show if the toggle is checked, or if it's a forced test
      if (!isTest && !hydrationToggle.checked) return;

      const popup = document.getElementById('hydrationPopup');
      popup.classList.add('show');
      playPleasantNoise();
      setTimeout(() => {
        popup.classList.remove('show');
      }, 20000); // 20 seconds
    }

    function playPleasantNoise() {
      if (customAudio) {
        customAudio.currentTime = 0;
        customAudio.play().catch(e => console.error("Error playing custom sound:", e));
        return;
      }
    }

    /* --- UPDATE MODAL LOGIC --- */
    const updateModal = document.getElementById('updateModal');
    const closeUpdateModalBtn = document.getElementById('closeUpdateModalBtn');
    const downloadUpdateBtn = document.getElementById('downloadUpdateBtn');
    const laterUpdateBtn = document.getElementById('laterUpdateBtn');
    const restartUpdateBtn = document.getElementById('restartUpdateBtn');
    const updateMessage = document.getElementById('updateMessage');

    function showUpdateModal() {
      updateModal.classList.add('visible');
    }

    function hideUpdateModal() {
      updateModal.classList.remove('visible');
    }

    closeUpdateModalBtn.addEventListener('click', hideUpdateModal);
    laterUpdateBtn.addEventListener('click', hideUpdateModal);

    downloadUpdateBtn.addEventListener('click', () => {
      if (window.electronAPI) {
        window.electronAPI.downloadUpdate();
        downloadUpdateBtn.textContent = "Downloading...";
        downloadUpdateBtn.disabled = true;
        laterUpdateBtn.disabled = true;
      }
    });

    restartUpdateBtn.addEventListener('click', () => {
      if (window.electronAPI) window.electronAPI.quitAndInstall();
    });

    if (window.electronAPI) {
      window.electronAPI.onUpdateAvailable((event, info) => {
        updateMessage.textContent = `Version ${info.version} is available. Would you like to download it now?`;
        showUpdateModal();
      });

      window.electronAPI.onUpdateDownloaded(() => {
        updateMessage.textContent = "Update downloaded and ready to install.";
        downloadUpdateBtn.style.display = 'none';
        laterUpdateBtn.style.display = 'none';
        restartUpdateBtn.style.display = 'inline-flex';
        showUpdateModal();
      });
    }

    /* --- FISSURE LOGIC --- */
    const fissureListEl = document.getElementById("fissureList");
    const refreshFissuresBtn = document.getElementById("refreshFissures");
    const toggleFiltersBtn = document.getElementById("toggleFilters");
    const filterMenuEl = document.getElementById("filterMenu");
    const resetTimersEl = document.getElementById("resetTimers");
    let lastFissuresData = [];
    let lastRenderedMissionTypes = [];
    let retryTimeout = null;
    let isFetchingFissures = false;
    let lastFetchTime = 0;

    // State for filters
    let hiddenMissionTypes = [];
    let hiddenTiers = [];
    let hiddenResetTiers = [];
    let showRailjack = false;

    toggleFiltersBtn.addEventListener("click", () => {
      filterMenuEl.classList.toggle("visible");
    });

    async function loadSettings() {
      try {
        if (window.electronAPI) {
          const settings = await window.electronAPI.getSettings();
          hiddenMissionTypes = settings.hiddenMissionTypes || [];
          hiddenTiers = settings.hiddenTiers || [];
          hiddenResetTiers = settings.hiddenResetTiers || [];
          showRailjack = settings.showRailjack || false;
          autoScanToggle.checked = settings.autoScanEnabled || false;
          
          scanIntervalNormalInput.value = settings.scanIntervalNormal || 10;
          scanIntervalCascadeInput.value = settings.scanIntervalCascade || 5;

          // Load Relic Name
          if (settings.relicName) {
            relicNameInput.value = settings.relicName;
          }

          // Load Rotation Mode
          if (settings.rotationMode) {
            currentMode = settings.rotationMode;
            rotationBtns.forEach(b => {
              if (b.dataset.mode === currentMode) b.classList.add('active');
              else b.classList.remove('active');
            });
          }

          // Load 1b1 Position
          if (settings.oneByOnePosition) {
            runningPosition = settings.oneByOnePosition;
            posBtns.forEach(b => {
              if (parseInt(b.dataset.pos) === runningPosition) b.classList.add('active');
              else b.classList.remove('active');
            });
          }
          update1b1Visibility();
          
          if (settings.voidCascadeMode) {
            isCascadeMode = true;
            cascadeBtn.classList.add('active');
          } else {
            isCascadeMode = false;
            cascadeBtn.classList.remove('active');
          }
          
          hotkeyEnabledToggle.checked = settings.hotkeyEnabled !== false;
          osdToggle.checked = settings.osdEnabled || false;
          osdOpacityInput.value = settings.osdOpacity || 1.0;
          osdScaleInput.value = settings.osdScale || 1.0;
          osdLockToggle.checked = settings.osdLocked || false;
          hideOSDWhenEmptyToggle.checked = (settings.ui && settings.ui.hideOSDWhenEmpty) || false;
          scanPauseInput.value = settings.autoScanPause || 30;
          updateScanAreaDisplay({ normal: settings.scanArea, voidCascade: settings.voidCascadeScanArea });
          
          hydrationToggle.checked = settings.hydrationReminderEnabled || false;
          manageHydrationTimer();
          hydrationIntervalInput.value = settings.hydrationIntervalMinutes || 60;
          hydrationVolumeInput.value = settings.hydrationSoundVolume !== undefined ? settings.hydrationSoundVolume : 0.5;
          updateSoundUI(settings.hydrationSound);
          loadCustomSoundData();

          // Load Layout
          if (settings.layout) {
            applyLayout(settings.layout);
          }
          if (settings.ui && settings.ui.customLayout) {
            // Custom layout loaded into memory but not applied automatically unless it was the last active one (which is handled by settings.layout)
          }

          uiSettings = settings.ui || {};
          
          // Load Scanner Preview Button State
          const showPreview = settings.ui.showScannerPreview !== false; // Default true
          const showScannerPreviewToggle = document.getElementById('showScannerPreviewToggle');
          if (showScannerPreviewToggle) {
             showScannerPreviewToggle.checked = showPreview;
          }
          toggleScannerPreview(showPreview);

          applyUISettings(uiSettings);
          updateColumnVisibility();
          broadcastOSD();
        }
      } catch (e) {
        console.error("Failed to load settings:", e);
      }
      loadFissures();
    }

    function saveFilters() {
      if (window.electronAPI) window.electronAPI.setFilters({ hiddenMissionTypes, hiddenTiers, hiddenResetTiers, showRailjack });
      loadFissures(); // Reload list to apply filters
    }

    function renderFilters(allMissionTypes) {
      filterMenuEl.innerHTML = "";

      const tiers = ['Lith', 'Meso', 'Neo', 'Axi', 'Requiem', 'Omnia'];

      // --- General Settings ---
      const generalSection = document.createElement("div");
      generalSection.innerHTML = `<div class="filter-section-title">General</div>`;
      const generalGrid = document.createElement("div");
      generalGrid.className = "filter-grid";
      
      const rjOption = document.createElement("label");
      rjOption.className = "filter-option";
      rjOption.innerHTML = `<input type="checkbox" ${showRailjack ? "checked" : ""}> <span style="color: #facc15;">Show Railjack</span>`;
      rjOption.querySelector("input").addEventListener("change", (e) => {
          showRailjack = e.target.checked;
          saveFilters();
      });
      generalGrid.appendChild(rjOption);
      generalSection.appendChild(generalGrid);
      filterMenuEl.appendChild(generalSection);

      // --- Fissure Tiers ---
      const tierSection = document.createElement("div");
      tierSection.innerHTML = `<div class="filter-section-title">Fissure Tiers</div>`;
      const tierGrid = document.createElement("div");
      tierGrid.className = "filter-grid";

      tiers.forEach(tier => {
        const label = document.createElement("label");
        label.className = "filter-option";
        const isHidden = hiddenTiers.includes(tier);
        label.innerHTML = `<input type="checkbox" ${!isHidden ? "checked" : ""}> ${tier}`;
        label.querySelector("input").addEventListener("change", (e) => {
          if (e.target.checked) hiddenTiers = hiddenTiers.filter(t => t !== tier);
          else if (!hiddenTiers.includes(tier)) hiddenTiers.push(tier);
          saveFilters();
        });
        tierGrid.appendChild(label);
      });
      tierSection.appendChild(tierGrid);
      filterMenuEl.appendChild(tierSection);

      // --- Reset Timers ---
      const resetSection = document.createElement("div");
      resetSection.innerHTML = `<div class="filter-section-title">Reset Timers</div>`;
      const resetGrid = document.createElement("div");
      resetGrid.className = "filter-grid";

      tiers.forEach(tier => {
        const label = document.createElement("label");
        label.className = "filter-option";
        const isHidden = hiddenResetTiers.includes(tier);
        label.innerHTML = `<input type="checkbox" ${!isHidden ? "checked" : ""}> ${tier}`;
        label.querySelector("input").addEventListener("change", (e) => {
          if (e.target.checked) hiddenResetTiers = hiddenResetTiers.filter(t => t !== tier);
          else if (!hiddenResetTiers.includes(tier)) hiddenResetTiers.push(tier);
          saveFilters();
        });
        resetGrid.appendChild(label);
      });
      resetSection.appendChild(resetGrid);
      filterMenuEl.appendChild(resetSection);

      // --- Mission Types ---
      const railjackTypes = ['Orphix', 'Skirmish', 'Volatile'];
      const ignoredTypes = ['Arena', 'Rush', 'Pursuit', 'Assault', 'Assassination', 'Corruption'];
      
      const normalMissions = [];
      const railjackMissions = [];
      
      allMissionTypes.sort().forEach(type => {
        if (ignoredTypes.includes(type)) return;
        if (railjackTypes.includes(type)) {
            railjackMissions.push(type);
        } else {
            normalMissions.push(type);
        }
      });

      const createMissionCheckbox = (type, container) => {
        const label = document.createElement("label");
        label.className = "filter-option";
        const isHidden = hiddenMissionTypes.includes(type);
        label.innerHTML = `<input type="checkbox" ${!isHidden ? "checked" : ""}> ${type}`;
        label.querySelector("input").addEventListener("change", (e) => {
          if (e.target.checked) {
            hiddenMissionTypes = hiddenMissionTypes.filter(t => t !== type);
          } else {
            if (!hiddenMissionTypes.includes(type)) hiddenMissionTypes.push(type);
          }
          saveFilters();
        });
        container.appendChild(label);
      };

      if (normalMissions.length > 0) {
          const missionSection = document.createElement("div");
          missionSection.innerHTML = `<div class="filter-section-title">Normal Missions</div>`;
          const missionGrid = document.createElement("div");
          missionGrid.className = "filter-grid";
          normalMissions.forEach(type => createMissionCheckbox(type, missionGrid));
          missionSection.appendChild(missionGrid);
          filterMenuEl.appendChild(missionSection);
      }

      if (railjackMissions.length > 0) {
          const rjSection = document.createElement("div");
          rjSection.innerHTML = `<div class="filter-section-title">Railjack Missions</div>`;
          const rjGrid = document.createElement("div");
          rjGrid.className = "filter-grid";
          railjackMissions.forEach(type => createMissionCheckbox(type, rjGrid));
          rjSection.appendChild(rjGrid);
          filterMenuEl.appendChild(rjSection);
      }
    }

    // Clock
    function updateClock() {
      const now = new Date();
      const timeString = now.toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit' });
      document.getElementById('clock').textContent = timeString;
    }
    setInterval(updateClock, 1000);
    updateClock();

    // Timer Logic
    function formatTimeLeft(expiryStr, showSeconds = true) {
      const now = new Date();
      const expiry = new Date(expiryStr);
      const diff = expiry - now;
      
      if (diff <= 0) return "Expired";
      
      const hours = Math.floor(diff / 3600000);
      const minutes = Math.floor((diff % 3600000) / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      
      if (hours > 0) return showSeconds ? `${hours}h ${minutes}m ${seconds}s` : `${hours}h ${minutes}m`;
      if (minutes > 0) return showSeconds ? `${minutes}m ${seconds}s` : `${minutes}m`;
      return `${seconds}s`;
    }

    function updateTimers() {
      const timers = document.querySelectorAll('.fissure-timer');
      const now = new Date();
      let shouldRefresh = false;

      timers.forEach(el => {
        let expiry = el.dataset.expiry;
        
        // Handle Reset Timers switching to Hard Expiry
        if (el.dataset.reset && el.dataset.hardExpiry) {
            const resetDate = new Date(el.dataset.reset);
            const hardDate = new Date(el.dataset.hardExpiry);

            if (now > resetDate) {
                expiry = el.dataset.hardExpiry;
                el.style.color = '#f87171'; // Red to indicate ending

                // Dynamic Polling:
                // If in "Red Zone" (Reset passed, Hard not reached), poll every 15s to catch early updates
                // If "Expired" (Hard passed), poll every 5s to find next rotation
                const pollInterval = (now < hardDate) ? 15000 : 5000;
                if (Date.now() - lastFetchTime > pollInterval) shouldRefresh = true;
            } else {
                el.style.color = '';
            }
        }

        const isReset = el.closest('#resetTimers') !== null;
        if (expiry) el.textContent = formatTimeLeft(expiry, !isReset);
      });

      // Check for waiting placeholders
      if (document.querySelectorAll('.reset-row.waiting').length > 0) {
          if (Date.now() - lastFetchTime > 10000) shouldRefresh = true;
      }

      if (shouldRefresh && !isFetchingFissures) {
          loadFissures();
      }
    }
    setInterval(updateTimers, 1000);

    const STANDARD_MISSION_TYPES = [
      'Alchemy', 'Assassination', 'Assault', 'Capture', 'Defense', 
      'Disruption', 'Excavation', 'Exterminate', 'Hijack', 'Hive', 'Interception', 
      'Mobile Defense', 'Orphix', 'Rescue', 'Sabotage', 'Skirmish', 'Spy', 
      'Survival', 'Volatile', 'Void Cascade', 'Void Flood'
    ];

    function renderFissures(fissures) {
        const now = new Date();
        
        // Fix mission type naming
        fissures.forEach(f => {
            if (f.missionType === 'Extermination') f.missionType = 'Exterminate';
        });

        const activeFissures = fissures.filter(f => new Date(f.expiry) > now);
        
        // Collect all mission types (Standard + any new ones from active fissures)
        const activeTypes = activeFissures.map(f => f.missionType).filter(Boolean);
        const allTypes = [...new Set([...STANDARD_MISSION_TYPES, ...activeTypes])].sort();
        
        const typesChanged = JSON.stringify(allTypes) !== JSON.stringify(lastRenderedMissionTypes);
        
        if (typesChanged) {
             renderFilters(allTypes);
             lastRenderedMissionTypes = allTypes;
        }
        
        // --- Reset Timer Logic (Column) ---
        resetTimersEl.innerHTML = "";
        resetTimersEl.style.display = "flex";
        const tiers = ['Lith', 'Meso', 'Neo', 'Axi', 'Requiem', 'Omnia'];
        
        tiers.forEach(tier => {
            if (hiddenResetTiers.includes(tier)) return;
            // Use activeFissures (all active) not displayFissures (filtered)
            const tierMissions = activeFissures.filter(f => f.tier === tier);
            
            if (tierMissions.length === 0) {
                // Show placeholder if no active missions found (waiting for rotation)
                const row = document.createElement('div');
                row.className = 'reset-row waiting';
                row.innerHTML = `<span class="reset-tier">${tier}</span><div class="reset-val" style="color:#52525b;">...</div>`;
                resetTimersEl.appendChild(row);
                return;
            }

            const normalMissions = tierMissions.filter(f => !f.isHard);
            const spMissions = tierMissions.filter(f => f.isHard);

            const getResetData = (missions) => {
                if (!missions.length) return null;
                // Find LATEST expiry
                const maxExpiryStr = missions.reduce((max, curr) => new Date(curr.expiry) > new Date(max) ? curr.expiry : max, missions[0].expiry);
                const maxExpiry = new Date(maxExpiryStr);
                // Reset is 2 mins before latest expiry
                return { reset: new Date(maxExpiry.getTime() - 2 * 60000), hard: maxExpiry };
            };

            const normalData = getResetData(normalMissions);
            const spData = getResetData(spMissions);

            if (normalData || spData) {
                const row = document.createElement('div');
                row.className = 'reset-row';
                let html = `<span class="reset-tier">${tier}</span><div class="reset-val">`;
                
                const generateTimerHtml = (label, data) => {
                    if (!data) return '';
                    let target = data.reset;
                    let style = '';
                    if (new Date() > data.reset) {
                        target = data.hard;
                        style = 'color:#f87171;';
                    }
                    return `<span>${label}: <span class="fissure-timer" style="background:transparent; padding:0; ${style}" data-expiry="${data.reset.toISOString()}" data-reset="${data.reset.toISOString()}" data-hard-expiry="${data.hard.toISOString()}">${formatTimeLeft(target, false)}</span></span>`;
                };

                if (normalData) html += generateTimerHtml('N', normalData);
                if (spData) html += generateTimerHtml('SP', spData);
                
                html += `</div>`;
                row.innerHTML = html;
                resetTimersEl.appendChild(row);
            }
        });

        // Filter logic
        const displayFissures = activeFissures.filter(f => {
          if (!f.tier) return false; // Basic validity check
          if (f.isStorm && !showRailjack) return false; // Railjack filter (default hidden)
          if (hiddenMissionTypes.includes(f.missionType)) return false; // User hidden types
          if (hiddenTiers.includes(f.tier)) return false; // User hidden tiers
          return true;
        });
        
        // Sort by Tier number (1=Lith, etc)
        displayFissures.sort((a, b) => a.tierNum - b.tierNum);

        fissureListEl.innerHTML = "";
        
        if (displayFissures.length === 0) {
          fissureListEl.innerHTML = '<div style="text-align:center; color:#666;">No active fissures found.</div>';
          return;
        }

        // Group by Tier
        const grouped = {};
        displayFissures.forEach(f => {
          if (!grouped[f.tier]) grouped[f.tier] = [];
          grouped[f.tier].push(f);
        });

        // Define order to ensure consistent display
        const tierOrder = tiers;

        // Render groups
        for (const tier of tierOrder) {
          if (grouped[tier]) {
            const groupDiv = document.createElement("div");
            groupDiv.className = "fissure-group";

            const header = document.createElement("div");
            header.className = "group-header";
            header.textContent = tier;
            groupDiv.appendChild(header);

            grouped[tier].forEach(f => {
              const item = document.createElement("div");
              item.className = `fissure-item ${f.tier}`;
              
              const spIcon = f.isHard ? `<svg class="sp-icon" viewBox="0 0 24 24" title="Steel Path"><path d="M12,2 L2,12 L12,22 L22,12 L12,2 Z M12,6 L18,12 L12,18 L6,12 L12,6 Z"/></svg>` : '';

              item.innerHTML = `
                <div class="fissure-info">
                  <span class="fissure-main">${f.missionType}${spIcon}</span>
                  <span class="fissure-sub">${f.node} ‚Ä¢ ${f.enemy}</span>
                </div>
                <div class="fissure-timer" data-expiry="${f.expiry}">${formatTimeLeft(f.expiry)}</div>
              `;
              groupDiv.appendChild(item);
            });
            fissureListEl.appendChild(groupDiv);
          }
        }
    }

    async function loadFissures() {
      if (!window.electronAPI) return;
      
      if (isFetchingFissures) return;

      if (retryTimeout) {
        clearTimeout(retryTimeout);
        retryTimeout = null;
      }

      isFetchingFissures = true;
      const btn = refreshFissuresBtn;
      btn.textContent = "...";
      btn.disabled = true;
      
      try {
        const fissures = await window.electronAPI.getFissures();
        lastFetchTime = Date.now();
        if (!Array.isArray(fissures)) throw new Error("Invalid data received");
        
        lastFissuresData = fissures;
        renderFissures(fissures);
      } catch (err) {
        console.error(err);
        lastFetchTime = Date.now();
        if (lastFissuresData.length > 0) renderFissures(lastFissuresData);
        else fissureListEl.innerHTML = '<div style="text-align:center; color:#f87171; margin-top:2rem;">Connection failed.<br>Retrying in 5s...</div>';
        
        // Retry until success
        retryTimeout = setTimeout(loadFissures, 5000);
      } finally {
        btn.textContent = "Refresh";
        btn.disabled = false;
        isFetchingFissures = false;
      }
    }

    refreshFissuresBtn.addEventListener("click", loadFissures);
    // Auto refresh every minute
    setInterval(loadFissures, 60000);

    /* --- LAYOUT & DRAG-DROP LOGIC --- */
    const editLayoutToggle = document.getElementById('editLayoutToggle');
    const layoutColumns = document.querySelectorAll('.layout-column');
    const draggablePanels = document.querySelectorAll('.draggable-panel');
    const presetDefaultBtn = document.getElementById('presetDefaultBtn');
    const presetCompactBtn = document.getElementById('presetCompactBtn');
    const saveCustomLayoutBtn = document.getElementById('saveCustomLayoutBtn');
    const loadCustomLayoutBtn = document.getElementById('loadCustomLayoutBtn');
    const layoutContainer = document.getElementById('layoutContainer');
    
    const showScannerPreviewToggle = document.getElementById('showScannerPreviewToggle');
    if (showScannerPreviewToggle) {
      showScannerPreviewToggle.addEventListener('change', () => {
        const show = showScannerPreviewToggle.checked;
        toggleScannerPreview(show);
        if (window.electronAPI) window.electronAPI.setUISettings({ showScannerPreview: show });
      });
    }

    /* --- UPDATE CHECK LOGIC --- */
    const checkForUpdateBtn = document.getElementById('checkForUpdateBtn');
    const updateStatusEl = document.getElementById('updateStatus');
    const kofiBtn = document.getElementById('kofiBtn');

    checkForUpdateBtn.addEventListener('click', () => {
      if (window.electronAPI) window.electronAPI.checkForUpdate();
    });

    if (kofiBtn) {
      kofiBtn.addEventListener('click', () => {
        if (window.electronAPI) window.electronAPI.openExternal('https://ko-fi.com/lysiohn');
      });
    }

    if (window.electronAPI) {
      window.electronAPI.onUpdateStatus((event, message) => {
        updateStatusEl.textContent = message;
      });
    }


    function toggleScannerPreview(show) {
      const btn = document.getElementById('testScannerBtn');
      const preview = document.getElementById('scannerPreview');
      if (btn) btn.style.display = show ? 'block' : 'none';
      if (!show && preview) preview.style.display = 'none';
    }

    let isEditingLayout = false;

    editLayoutToggle.addEventListener('change', () => {
      isEditingLayout = editLayoutToggle.checked;
      toggleEditMode(isEditingLayout);
    });

    function toggleEditMode(enabled) {
      layoutColumns.forEach(col => {
        if (enabled) col.classList.add('editing');
        else col.classList.remove('editing');
      });
      draggablePanels.forEach(panel => {
        panel.draggable = enabled;
      });
    }

    // Drag Events
    draggablePanels.forEach(panel => {
      panel.addEventListener('dragstart', () => {
        panel.classList.add('dragging');
      });
      panel.addEventListener('dragend', () => {
        panel.classList.remove('dragging');
        saveLayout();
      });
    });

    layoutColumns.forEach(col => {
      col.addEventListener('dragover', (e) => {
        e.preventDefault();
        const afterElement = getDragAfterElement(col, e.clientY);
        const draggable = document.querySelector('.dragging');
        if (afterElement == null) {
          col.appendChild(draggable);
        } else {
          col.insertBefore(draggable, afterElement);
        }
      });
    });

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.draggable-panel:not(.dragging)')];
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function getColumnData(colId) {
      const col = document.getElementById(colId);
      if (!col) return { width: null, panels: [] };
      const panels = Array.from(col.children).map(child => ({
        id: child.id,
        // height: child.style.height || null // Don't save height
      }));
      return {
        // width: col.style.width || null, // Don't save width
        panels: panels
      };
    }

    function saveLayout() {
      const layout = {
        col2: getColumnData('col-2'),
        col3: getColumnData('col-3')
      };
      if (window.electronAPI) window.electronAPI.setLayout(layout);
      return layout;
    }

    function applyLayout(layout) {
      if (!layout) return;
      
      const applyCol = (colId, colData) => {
        const col = document.getElementById(colId);
        if (!col) return;
        let panelIds = [];

        if (Array.isArray(colData)) {
          panelIds = colData;
        } else if (colData && typeof colData === 'object') {
          panelIds = colData.panels.map(p => typeof p === 'string' ? p : p.id);
        }

        // Reset styles
        col.style.flex = "";
        col.style.width = "";

        panelIds.forEach(id => {
          const panel = document.getElementById(id);
          if (panel) {
             col.appendChild(panel);
             panel.style.height = ""; // Reset height
          }
        });
      };

      applyCol('col-2', layout.col2);
      applyCol('col-3', layout.col3);
    }

    // Presets
    const presets = {
      default: {
        col2: { width: null, panels: [{id: 'panel-runner', height: null}, {id: 'panel-hotkey', height: null}, {id: 'panel-scanner', height: null}, {id: 'panel-osd', height: null}] },
        col3: { width: null, panels: [{id: 'panel-fissures', height: '100%'}] }
      },
      compact: {
        col2: { width: null, panels: [{id: 'panel-runner', height: null}, {id: 'panel-fissures', height: '400px'}, {id: 'panel-hotkey', height: null}, {id: 'panel-scanner', height: null}, {id: 'panel-osd', height: null}] },
        col3: { width: null, panels: [] }
      }
    };

    presetDefaultBtn.addEventListener('click', () => { applyLayout(presets.default); saveLayout(); });
    presetCompactBtn.addEventListener('click', () => { applyLayout(presets.compact); saveLayout(); });

    saveCustomLayoutBtn.addEventListener('click', () => {
      const layout = saveLayout(); // Saves to current active layout
      if (window.electronAPI) {
        // Also save to custom slot
        window.electronAPI.setUISettings({ customLayout: layout });
        alert("Layout saved as Custom Preset!");
      }
    });

    loadCustomLayoutBtn.addEventListener('click', () => {
      if (uiSettings && uiSettings.customLayout) {
        applyLayout(uiSettings.customLayout);
        saveLayout();
      } else {
        alert("No custom preset saved.");
      }
    });
    // Load on startup (moved to end to ensure all variables are defined)
    loadSettings();

  </script>
</body>
</html>
